# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'cadastro.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import sqlite3
from PyQt5.QtCore import Qt
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QMessageBox,QHeaderView,QApplication, QMainWindow, QVBoxLayout, QWidget, QLineEdit, QTableWidget, QTableWidgetItem,QShortcut
from PyQt5.QtGui import QKeySequence
from datetime import datetime
from PyQt5.QtCore import Qt, QRect
import serial
#import serial.tools.list_ports
import requests
import serial.tools.list_ports




class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1000, 627)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.tableWidget = QtWidgets.QTableWidget(self.centralwidget)
        self.tableWidget.setGeometry(QtCore.QRect(10, 220, 451, 331))
        self.tableWidget.setObjectName("tableWidget")
        self.tableWidget.setColumnCount(0)
        self.tableWidget.setRowCount(0)
        self.adicionar = QtWidgets.QPushButton(self.centralwidget)
        self.adicionar.setGeometry(QtCore.QRect(30, 190, 75, 24))
        self.adicionar.setObjectName("adicionar")
        self.deletar = QtWidgets.QPushButton(self.centralwidget)
        self.deletar.setGeometry(QtCore.QRect(120, 190, 75, 24))
        self.deletar.setObjectName("deletar")
        self.codigo = QtWidgets.QLineEdit(self.centralwidget)
        self.codigo.setGeometry(QtCore.QRect(70, 90, 113, 22))
        self.codigo.setObjectName("codigo")
        self.produto = QtWidgets.QLineEdit(self.centralwidget)
        self.produto.setGeometry(QtCore.QRect(70, 120, 113, 22))
        self.produto.setObjectName("produto")
        self.valor = QtWidgets.QLineEdit(self.centralwidget)
        self.valor.setGeometry(QtCore.QRect(70, 150, 113, 22))
        self.valor.setObjectName("valor")
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(20, 90, 71, 21))
        self.label.setObjectName("label")
        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        self.label_2.setGeometry(QtCore.QRect(20, 120, 51, 16))
        self.label_2.setObjectName("label_2")
        self.label_3 = QtWidgets.QLabel(self.centralwidget)
        self.label_3.setGeometry(QtCore.QRect(20, 150, 49, 16))
        self.label_3.setObjectName("label_3")
        self.label_4 = QtWidgets.QLabel(self.centralwidget)
        self.label_4.setGeometry(QtCore.QRect(100, 30, 49, 16))
        self.label_4.setObjectName("label_4")
        self.carregar = QtWidgets.QPushButton(self.centralwidget)
        self.carregar.setGeometry(QtCore.QRect(70, 60, 111, 21))
        self.carregar.setObjectName("carregar")
        self.label_5 = QtWidgets.QLabel(self.centralwidget)
        self.label_5.setGeometry(QtCore.QRect(280, 10, 121, 31))
        self.label_5.setObjectName("label_5")
        self.label_6 = QtWidgets.QLabel(self.centralwidget)
        self.label_6.setGeometry(QtCore.QRect(20, 560, 441, 16))
        self.label_6.setObjectName("label_6")
        self.showtotal = QtWidgets.QLCDNumber(self.centralwidget)
        self.showtotal.setGeometry(QtCore.QRect(470, 490, 201, 61))
        self.showtotal.setObjectName("showtotal")
        self.showtotal.setDigitCount(9)
        app.aboutToQuit.connect(self.upload)
        #self.download()

        self.f10 = QtWidgets.QPushButton(self.centralwidget)
        self.f10.setGeometry(QtCore.QRect(540, 20, 111, 21))
        self.f10.setObjectName("carregar")
        self.f10.clicked.connect(self.imprimir)


        self.f12 = QtWidgets.QPushButton(self.centralwidget)
        self.f12.setGeometry(QtCore.QRect(470, 210, 111, 21))
        self.f12.setObjectName("carregar")
        self.f12.clicked.connect(self.imprimirf12)
        
        self.showentrada = QtWidgets.QLCDNumber(self.centralwidget)
        self.showentrada.setGeometry(QtCore.QRect(680, 490, 201, 61))
        self.showentrada.setObjectName("showentrada")
        self.showentrada.setDigitCount(9)

        self.showsaida = QtWidgets.QLCDNumber(self.centralwidget)
        self.showsaida.setGeometry(QtCore.QRect(880, 490, 201, 61))
        self.showsaida.setObjectName("showsaida")
        self.showsaida.setDigitCount(9)

        
        self.label_7 = QtWidgets.QLabel(self.centralwidget)
        self.label_7.setGeometry(QtCore.QRect(480, 450, 201, 31))
        font = QtGui.QFont()
        font.setFamily("Courier")
        font.setPointSize(10)
        font.setBold(True)
        font.setItalic(False)
        font.setUnderline(False)
        font.setStrikeOut(False)
        self.label_7.setFont(font)
        self.label_7.setIndent(1)
        self.label_7.setObjectName("label_7")
        #self.tableWidget_2 = QTableWidget(self)
        #self.tableWidget_2.setColumnCount(1)  # Uma coluna para os nomes das tabelas
        #self.tableWidget_2.setHorizontalHeaderLabels(["Nome da Tabela"])
        self.tableWidget.itemChanged.connect(self.handleItemChanged)

        self.label_8 = QtWidgets.QLabel(self.centralwidget)
        self.label_8.setGeometry(QtCore.QRect(670, 10, 201, 31))
        self.label_8.setFont(font)
        self.label_8.setIndent(1)
        self.label_8.setObjectName("label_7")

        self.label_9 = QtWidgets.QLabel(self.centralwidget)
        self.label_9.setGeometry(QtCore.QRect(700, 450, 201, 31))
        self.label_9.setFont(font)
        self.label_9.setIndent(1)
        self.label_9.setObjectName("label_9")


        self.label_10 = QtWidgets.QLabel(self.centralwidget)
        self.label_10.setGeometry(QtCore.QRect(920, 450, 201, 31))
        self.label_10.setFont(font)
        self.label_10.setIndent(1)
        self.label_10.setObjectName("label_10")


        self.Fluxo = QTableWidget(self.centralwidget)
        self.Fluxo.setObjectName(u"Fluxo")
        self.Fluxo.setGeometry(QtCore.QRect(470, 51, 601, 161))
        
        self.fre = QtWidgets.QPushButton(self.centralwidget)
        self.fre.setObjectName(u"fre")
        self.fre.setGeometry(QRect(440, 220, 21, 20))
        self.fre.clicked.connect(self.proxima_pagina)
        
        self.ret = QtWidgets.QPushButton(self.centralwidget)
        self.ret.setObjectName(u"ret")
        self.ret.setGeometry(QRect(10, 220, 21, 23))
        self.ret.clicked.connect(self.pagina_anterior
                                 )
        self.tableWidget_2 = QtWidgets.QTableWidget(self.centralwidget)
        self.tableWidget_2.setGeometry(QtCore.QRect(200, 50, 261, 161))
        self.tableWidget_2.setObjectName("tableWidget_2")
        #self.tableWidget_2.setHorizontalHeaderVisible(True)
        self.tableWidget_2.setColumnCount(0)
        self.tableWidget_2.setRowCount(0)
        self.listWidget = QtWidgets.QTableWidget(self.centralwidget)
        self.listWidget.setGeometry(QtCore.QRect(470, 230, 601, 221))
        self.listWidget.setObjectName("listWidget")
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 799, 22))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
#
        self.produtos_carregar()
        self.carregar.clicked.connect(self.produtos_carregar)
#
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
#
        self.vendas_dia()
#
        self.tableWidget_2.cellClicked.connect(self.carregar_planilha)
#
        self.deletar.clicked.connect(self.deletarLinha)
        self.tableWidget.itemChanged.connect(self.cellChanged)



        #
        self.adicionar.clicked.connect(self.add_produtos)
    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Cadastro Produtos"))
        self.adicionar.setText(_translate("MainWindow", "Adicionar"))
        self.deletar.setText(_translate("MainWindow", "Deletar"))
        self.codigo.setPlaceholderText(_translate("MainWindow", "Insira o Codigo"))
        self.produto.setPlaceholderText(_translate("MainWindow", "Insira o produto"))
        self.valor.setPlaceholderText(_translate("MainWindow", "Insira o valor"))
        self.label.setText(_translate("MainWindow", "Codigo:"))
        self.label_2.setText(_translate("MainWindow", "Produto:"))
        self.label_3.setText(_translate("MainWindow", "Valor:"))
        self.label_4.setText(_translate("MainWindow", "Produtos"))
        self.carregar.setText(_translate("MainWindow", "Carregar Produtos"))
        self.f10.setText(_translate("MainWindow", "Imprimir Fluxo dia"))
        self.f12.setText(_translate("MainWindow", "Relação Vendas"))

        self.fre.setText(_translate("MainWindow", u">", None))
        self.ret.setText(_translate("MainWindow", u"<", None))

        self.label_5.setText(_translate("MainWindow", "Consulta Vendas dia"))
        self.label_6.setText(_translate("MainWindow", "Criado por: Alldo Roberto. Contatos:(21)96455-8805 | chasealdorobert@gmail.com"))
        self.label_7.setText(_translate("MainWindow", "Total vendas do dia"))
        self.label_8.setText(_translate("MainWindow", "Fluxo do Caixa"))
        self.label_9.setText(_translate("MainWindow", "Total Entrada"))
        self.label_10.setText(_translate("MainWindow", "Total Saida"))


        colunas = ["Vendas dia"]  # Substitua pelo nome das suas colunas
        self.tableWidget_2.setColumnCount(len(colunas))
        self.tableWidget_2.setHorizontalHeaderLabels(colunas)
    
    def upload(self):
        # URL onde você fará o upload do arquivo
        url_upload = 'https://allldo.pythonanywhere.com/upload_db'

        # Nome do arquivo local que você deseja fazer o upload
        nome_arquivo_local = 'vendas.db'

        # Abra o arquivo local para leitura binária
        with open(nome_arquivo_local, 'rb') as arquivo:
            # Faça uma solicitação POST para o URL de upload, enviando o arquivo como um arquivo multipart
            response = requests.post(url_upload, files={'file': arquivo})

        # Verifique se a solicitação foi bem-sucedida (código de status HTTP 200)
        if response.status_code == 200:
            print("Arquivo de banco de dados enviado com sucesso.")
        else:
            # Imprima uma mensagem de erro se a solicitação falhar
            print("Erro ao fazer upload do arquivo:", response.status_code)
    
    
    
    def download(self):
        
        url = 'https://allldo.pythonanywhere.com/download'  # Substitua pelo URL fornecido
        nome_arquivo_local = 'vendas.db'  # Nome do arquivo local onde você deseja salvar o banco de dados

        # Faça a solicitação HTTP GET para o URL
        response = requests.get(url)

        # Verifique se a solicitação foi bem-sucedida (código de status HTTP 200)
        if response.status_code == 200:
            # Salve o conteúdo da resposta no arquivo local
            with open(nome_arquivo_local, 'wb') as f:
                f.write(response.content)
            print(f"Banco de dados baixado com sucesso como {nome_arquivo_local}")
        else:
            # Imprima uma mensagem de erro se a solicitação falhar
            print("Erro ao baixar o banco de dados:", response.status_code) 
    
    def cellChanged(self, item):
    # Verifique se a coluna da célula alterada é a coluna "Quantidade"
        if item.column() == 2:  # Supondo que a coluna "Quantidade" seja a segunda coluna (índice 1)
            new_value = self.tableWidget.item(item.row(), 2).text()  # Obtém o valor da coluna "Quantidade" da mesma linha
            row_id = self.tableWidget.item(item.row(), 0).text()  # Obtém o valor da coluna "ID" da mesma linha
            product_name = self.tableWidget.item(item.row(), 1).text()  # Obtém o valor da coluna "NomeProduto" da mesma linha

            # Atualize o valor na tabela "produtos" do banco de dados "vendas.db" apenas para a linha correta
            connection = sqlite3.connect('vendas.db')
            cursor = connection.cursor()
            update_query = "UPDATE produtos SET Quantidade = ? WHERE Código = ? AND Produto = ?"
            cursor.execute(update_query, (new_value, row_id, product_name))
            connection.commit()
        
        if item.column() == 3:  # Supondo que a coluna "Quantidade" seja a segunda coluna (índice 1)
            new_value = self.tableWidget.item(item.row(), 3).text()  # Obtém o valor da coluna "Quantidade" da mesma linha
            row_id = self.tableWidget.item(item.row(), 0).text()  # Obtém o valor da coluna "ID" da mesma linha
            product_name = self.tableWidget.item(item.row(), 1).text()  # Obtém o valor da coluna "NomeProduto" da mesma linha

            # Atualize o valor na tabela "produtos" do banco de dados "vendas.db" apenas para a linha correta
            connection = sqlite3.connect('vendas.db')
            cursor = connection.cursor()
            update_query = "UPDATE produtos SET Valor = ? WHERE Código = ? AND Produto = ?"
            cursor.execute(update_query, (new_value, row_id, product_name))
            connection.commit()
        
        if item.column() == 1:  # Supondo que a coluna "Quantidade" seja a segunda coluna (índice 1)
            new_value = self.tableWidget.item(item.row(), 1).text()  # Obtém o valor da coluna "Quantidade" da mesma linha
            row_id = self.tableWidget.item(item.row(), 0).text()  # Obtém o valor da coluna "ID" da mesma linha
            #product_name = self.tableWidget.item(item.row(), 1).text()  # Obtém o valor da coluna "NomeProduto" da mesma linha

            # Atualize o valor na tabela "produtos" do banco de dados "vendas.db" apenas para a linha correta
            connection = sqlite3.connect('vendas.db')
            cursor = connection.cursor()
            update_query = "UPDATE produtos SET Produto = ? WHERE Código = ? "
            cursor.execute(update_query, (new_value, row_id))
            connection.commit()

        if item.column() == 0:  # Supondo que a coluna "Quantidade" seja a primeira coluna (índice 0)
            new_value_item = self.tableWidget.item(item.row(), 0)
            row_id_item = self.tableWidget.item(item.row(), 1)

            # Verifica se os itens não são None antes de acessar seus atributos
            if new_value_item is not None and row_id_item is not None:
                new_value = new_value_item.text()  # Obtém o valor da coluna "Quantidade" da mesma linha
                row_id = row_id_item.text()  # Obtém o valor da coluna "ID" da mesma linha

                # Atualize o valor na tabela "produtos" do banco de dados "vendas.db" apenas para a linha correta
                connection = sqlite3.connect('vendas.db')
                cursor = connection.cursor()
                update_query = "UPDATE produtos SET Código = ? WHERE Produto = ? "
                cursor.execute(update_query, (new_value, row_id))
                connection.commit()
   
    def produtos_carregar(self):
    # Define o número de itens por página e a página atual
        self.itens_por_pagina = 50
        self.pagina_atual = 1

        # Atualiza a tabela com os dados da página atual
        self.carregar_pagina()

    def carregar_pagina(self):
    # Limpa o conteúdo da tabela existente
        self.tableWidget.setRowCount(0)

        # Conecta ao banco de dados
        connection = sqlite3.connect('vendas.db')
        cursor = connection.cursor()

        # Execute a consulta para obter o total de itens
        cursor.execute("SELECT COUNT(*) FROM Produtos")
        total_itens = cursor.fetchone()[0]

        # Calcula o número total de páginas
        self.num_paginas = (total_itens + self.itens_por_pagina - 1) // self.itens_por_pagina

        # Garante que a página atual está dentro dos limites
        self.pagina_atual = max(1, min(self.pagina_atual, self.num_paginas))
        #print("Página atual:", self.pagina_atual)

        # Calcule o offset para a consulta SQL
        offset = (self.pagina_atual - 1) * self.itens_por_pagina

        # Execute a consulta para buscar os dados da página atual
        cursor.execute("SELECT * FROM Produtos LIMIT ? OFFSET ?",
                        (self.itens_por_pagina, offset))
        dados = cursor.fetchall()

        # Fecha a conexão com o banco de dados
        connection.close()

        # Define o número de linhas e colunas na tabela
        num_linhas = len(dados)
        num_colunas = len(dados[0]) if num_linhas > 0 else 0
        self.tableWidget.setRowCount(num_linhas)
        self.tableWidget.setColumnCount(num_colunas)

        # Preenche a tabela com os dados
        for linha_idx, linha in enumerate(dados):
            for coluna_idx, valor in enumerate(linha):
                item = QTableWidgetItem(str(valor))
                self.tableWidget.setItem(linha_idx, coluna_idx, item)

        # Redimensiona automaticamente as colunas para se ajustarem ao conteúdo
        self.tableWidget.resizeColumnsToContents()

        # Define os nomes das colunas (se houver dados)
        if num_linhas > 0:
            colunas = [str(coluna[0]) for coluna in cursor.description]
            self.tableWidget.setHorizontalHeaderLabels(colunas)



    def pagina_anterior(self):
        # Retrocede para a página anterior, se possível
        if self.pagina_atual > 1:
            self.pagina_atual -= 1
            self.carregar_pagina()

    def proxima_pagina(self):
        # Avança para a próxima página, se possível
        if self.pagina_atual < self.num_paginas:
            self.pagina_atual += 1
            self.carregar_pagina()

    def handleItemChanged(self, item):
        row = self.tableWidget.row(item)
        col = item.column()
        new_value = item.text()

        connection = sqlite3.connect('vendas.db')
        cursor = connection.cursor()

        if col == 0:  # Se a coluna editada for "Código"
            current_codigo = self.tableWidget.item(row, 0).text()  # Obtenha o código atual
            cursor.execute('UPDATE Produtos SET codigo = ? WHERE codigo = ?', (new_value, current_codigo))
        elif col == 1:  # Se a coluna editada for "Produto"
            current_produto = self.tableWidget.item(row, 1).text()  # Obtenha o produto atual
            cursor.execute('UPDATE Produtos SET Produto = ? WHERE Produto = ?', (new_value, current_produto))
        elif col == 2:  # Se a coluna editada for "Valor"
            current_valor = self.tableWidget.item(row, 2).text()  # Obtenha o valor atual
            cursor.execute('UPDATE Produtos SET Valor = ? WHERE Valor = ?', (new_value, current_valor))

        connection.commit()
        connection.close()
                
            


    def vendas_dia(self):

        conn = sqlite3.connect('vendas.db')
        cursor = conn.cursor()

        # Obtenha a lista de tabelas no banco de dados
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
        tabelas = cursor.fetchall()

        # Feche a conexão com o banco de dados
        conn.close()

        # Preencha o QTableWidget com os nomes das tabelas, excluindo "Produtos"
        for tabela in tabelas:
            nome_tabela = tabela[0]
            if nome_tabela != "Produtos" and not nome_tabela.startswith("dia"):
                row_position = self.tableWidget_2.rowCount()
                self.tableWidget_2.insertRow(row_position)
                item = QTableWidgetItem(nome_tabela)
                self.tableWidget_2.setItem(row_position, 0, item)
        self.tableWidget_2.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)

    def carregar_planilha(self, row, col):
        # Obtenha o nome da planilha da coluna correspondente à linha clicada
        nome_planilha = self.tableWidget_2.item(row, 0).text()

        # Abra o banco de dados SQLite
        conn = sqlite3.connect('vendas.db')
        cursor = conn.cursor()

        # Execute uma consulta SQL para obter os dados da planilha com base no nome
        cursor.execute(f"SELECT * FROM {nome_planilha}")
        dados_planilha = cursor.fetchall()

        # Feche a conexão com o banco de dados
        conn.close()
        nomes_colunas = ["Hora", "Produto", "valor","Cartão","Dinheiro","Total"]  # Substitua com os nomes reais das colunas

        # Feche a conexão com o banco de dados
        conn.close()
#

        # Preencha a tabela com os dados da planilha
        self.listWidget.setRowCount(len(dados_planilha) + 1)  # +1 para incluir a linha de nomes de coluna
        self.listWidget.setColumnCount(len(dados_planilha[0]))  # Supondo que todos os dados da planilha tenham o mesmo número de colunas
        colunas = [str(coluna[0]) for coluna in cursor.description]
        self.listWidget.setHorizontalHeaderLabels(colunas)
        # Insira uma nova linha na parte superior com os nomes das colunas
        for col_idx, nome_coluna in enumerate(nomes_colunas):
            item = QTableWidgetItem(nome_coluna)
            self.listWidget.setItem(0, col_idx, item)

        # Preencha o restante da tabela com os dados da planilha
        for row_idx, row_data in enumerate(dados_planilha):
            for col_idx, cell_data in enumerate(row_data):
                if cell_data is None:
                    cell_data = ''  # Substitui o valor None por um espaço em branco
                item = QTableWidgetItem(str(cell_data))
                self.listWidget.setItem(row_idx + 1, col_idx, item)

            self.listWidget.verticalHeader().setSectionResizeMode(QHeaderView.Fixed)

        self.listWidget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.lcd_display()

        ####################Planilhaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa##########################
         # Obtenha o nome da tabela desejada
        datedia1 = datetime.today().strftime("%d%m%Y")  # Adiciona o ano completo (com 4 dígitos)
        #flux = f'flux{datedia1}'
        parte_final = datedia1[-8:]
        #parte_final = parte_final[::-1]


        nome_tabela1 = f"dia_{parte_final}".replace('.', '_')

        # Conecte-se ao banco de dados
        conn = sqlite3.connect("vendas.db")
        cursor = conn.cursor()
        print(nome_tabela1)
        cursor.execute(f"SELECT SUM(Entrada) AS TotalEntrada, SUM(Saida) AS TotalSaida FROM {nome_tabela1}")
        soma = cursor.fetchone()  # Obtém o resultado da consulta
        total_entrada = soma[0] if soma[0] is not None else 0  # Soma de Entrada
        total_saida = soma[1] if soma[1] is not None else 0  # Soma de Saída
        self.showentrada.display(total_entrada)
        self.showsaida.display(total_saida)

        # Atualiza a coluna "Total" na linha 1 com o valor da soma
        cursor.execute(f"UPDATE {nome_tabela1} SET Total = {total_entrada - total_saida} WHERE rowid = 1")

        # Commit para salvar as alterações
        conn.commit()

       
       
        # Execute a consulta SQL para selecionar todos os dados da tabela
        cursor.execute(f"SELECT * FROM {nome_tabela1}")
        dados = cursor.fetchall()

        # Feche a conexão com o banco de dados
        conn.close()

        # Limpe o conteúdo da tabela existente
        self.Fluxo.setRowCount(0)

        # Preencha a tabela com os dados
        if dados:
            num_linhas = len(dados)
            num_colunas = len(dados[0])

            self.Fluxo.setRowCount(num_linhas)
            self.Fluxo.setColumnCount(num_colunas)

            for linha_idx, linha in enumerate(dados):
                for coluna_idx, valor in enumerate(linha):
                    item = QTableWidgetItem(str(valor))
                    self.Fluxo.setItem(linha_idx, coluna_idx, item)

            self.Fluxo.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)

            # Defina os nomes das colunas
            colunas = [str(coluna[0]) for coluna in cursor.description]
            self.Fluxo.setHorizontalHeaderLabels(colunas)

    def imprimir(self):
        # Conecte-se ao banco de dados
        # Obtenha a data formatada
        datedia1 = datetime.today().strftime("%d%m%Y")  # Adiciona o ano completo (com 4 dígitos)
        parte_final = datedia1[-8:]

        # Crie o nome da tabela com base na parte final da data
        nome_tabela1 = f"dia_{parte_final}".replace('.', '_')

        # Conecte-se ao banco de dados
        conn = sqlite3.connect("vendas.db")
        cursor = conn.cursor()

        # Execute a consulta SQL para calcular a soma da coluna "Entrada"
        cursor.execute(f"SELECT hora, entrada, Descr FROM {nome_tabela1} WHERE Entrada IS NOT NULL")

        # Obtém todas as linhas resultantes da consulta
        linhas = cursor.fetchall()

        # Crie strings para salvar os valores
        strings_hora_entrada = []

        # Itere pelas linhas e salve as informações desejadas nas strings
        for linha in linhas:
            hora, entrada, Descr = linha
            strings_hora_entrada.append(f"Hora: {hora}, Descricao:{Descr} Entrada: {entrada}")

        # Feche a conexão com o banco de dados
        conn.close()

        # Agora, a lista 'strings_hora_entrada' contém as informações de hora e entrada das linhas onde "entrada" não é nulo
        for linha_str in strings_hora_entrada:
            print(linha_str)


        conn = sqlite3.connect("vendas.db")
        cursor = conn.cursor()
        cursor.execute(f"SELECT hora, Saida, Desc FROM {nome_tabela1} WHERE Saida IS NOT NULL")

        # Obtém todas as linhas resultantes da consulta
        ss = cursor.fetchall()

        # Crie strings para salvar os valores
        strings_hora_saida = []

        # Itere pelas linhas e salve as informações desejadas nas strings
        for s in ss:
            horas, saida, Desc = s
            strings_hora_saida.append(f"Hora: {horas},Descrição: {Desc} Saida: {saida}")

        # Feche a conexão com o banco de dados
        conn.close()

        # Agora, a lista 'strings_hora_entrada' contém as informações de hora e entrada das linhas onde "entrada" não é nulo
        for linha_stro in strings_hora_saida:
            print(linha_stro)
            
        ports = list(serial.tools.list_ports.comports())

        # Verifica se há alguma porta disponível
        if ports:
            # Escolhe a primeira porta da lista (você pode personalizar a lógica de escolha)
            porta_serial = ports[0].device
        else:
            print("Nenhuma porta serial disponível.")
            # Aqui você pode tratar o caso de nenhuma porta estar disponível

        # Inicializa a conexão com a impressora
        #ser = serial.Serial(porta_serial, 9600)  # Substitua 9600 pela taxa de transmissão apropriada

        # Crie um modelo de impressão vazio
        modelo_impressao = """
                        Obrigado volte sempre!!!
                        
----------------------------------------------------
                """
        for ent in strings_hora_entrada:   
            modelo_impressao += f"\n{ent}"
        
        for sd in strings_hora_saida:
            modelo_impressao += f"\n{sd}"





        #cart= self.pagoLinha1.setText()
       # dinheiro= self.pagoLinhax.setText()



        # Comandos ESC/POS para imprimir o modelo
        comandos = [
            b'\x1B\x40',  # Inicializar a impressora
            b'\x1B\x61\x01',  # Centralizar o texto
            modelo_impressao.encode('utf-8'),
            b'\x1B\x61\x00',  # Alinhar o texto à esquerda
            b'\x0A',  # Avançar uma linha (pular)
            b'\x1D\x56\x01',  # Cortar o papel (parcial)
        ]

        # Enviar os comandos para a impressora
        for comando in comandos:
            ser.write(comando)
        print('Imprimiu')
        # Fechar a conexão com a impressora
        ser.close()


        # Salvar o resultado em um arquivo TXT
        with open('resultado.txt', 'w', encoding='utf-8') as file:
            file.write(modelo_impressao)

        # Abrir o arquivo TXT automaticamente
        import os
        os.system('notepad resultado.txt')



    def imprimirf12(self):
        # Conecte-se ao banco de dados
        # Obtenha a data formatada
        datedia1 = datetime.today().strftime("%d%m%Y")  # Adiciona o ano completo (com 4 dígitos)
        parte_final = datedia1[-8:]

        # Crie o nome da tabela com base na parte final da data
        nome_tabela1 = f"vendas_{parte_final}".replace('.', '_')

        # Conecte-se ao banco de dados
        conn = sqlite3.connect("vendas.db")
        cursor = conn.cursor()

        # Execute a consulta SQL para calcular a soma da coluna "Entrada"
        cursor.execute(f"SELECT Hora, Cartao, Pix, Dinheiro, Total FROM {nome_tabela1} WHERE Total IS NOT NULL")

        # Obtém todas as linhas resultantes da consulta
        linhas = cursor.fetchall()

        # Crie strings para salvar os valores
        strings_hora_entrada = []
        soma_cartao = 0
        soma_pix = 0
        soma_dinheiro = 0
        total = 0
        # Itere pelas linhas e salve as informações desejadas nas strings
        for linha in linhas:
            hora,Cartao, Pix, Dinheiro,Total = linha
            soma_cartao += Cartao
            soma_pix += Pix
            soma_dinheiro += Dinheiro
            total += Total
            strings_hora_entrada.append(f"Hora: {hora}  Cartao:  R$:{Cartao}  Pix: R$:{Pix}  Dinheiro  R$:{Dinheiro}")

        # Feche a conexão com o banco de dados
        conn.close()

        # Agora, a lista 'strings_hora_entrada' contém as informações de hora e entrada das linhas onde "entrada" não é nulo
        for linha_str in strings_hora_entrada:
            print(linha_str)
        total_vend = soma_cartao + soma_dinheiro + soma_pix
        ports = list(serial.tools.list_ports.comports())

        # Verifica se há alguma porta disponível
        if ports:
            # Escolhe a primeira porta da lista (você pode personalizar a lógica de escolha)
            porta_serial = ports[0].device
        else:
            print("Nenhuma porta serial disponível.")
            # Aqui você pode tratar o caso de nenhuma porta estar disponível

        # Inicializa a conexão com a impressora
        #ser = serial.Serial(porta_serial, 9600)  # Substitua 9600 pela taxa de transmissão apropriada

        parte_final = datedia1[-8:]

        # Crie um modelo de impressão vazio
        modelo_impressao = f"""
                    Volte Sempre!!!
---------------------------------------------------------------------------
                         Relação Vendas - {parte_final}
                """
        for ent in strings_hora_entrada:   
            modelo_impressao += f"\n{ent}\n"
        modelo_impressao += f"\n Total Cartão: R$ {soma_cartao}  Total Pix: R$ {soma_pix}  Total Dinheiro: R$ {soma_dinheiro} \n Venda Total: R$ {total}"


        





        #cart= self.pagoLinha1.setText()
    # dinheiro= self.pagoLinhax.setText()



        # Comandos ESC/POS para imprimir o modelo
        comandos = [
            b'\x1B\x40',  # Inicializar a impressora
            b'\x1B\x61\x01',  # Centralizar o texto
            modelo_impressao.encode('utf-8'),
            b'\x1B\x61\x00',  # Alinhar o texto à esquerda
            b'\x0A',  # Avançar uma linha (pular)
            b'\x1D\x56\x01',  # Cortar o papel (parcial)
        ]

        # Enviar os comandos para a impressora
        #for comando in comandos:
            #ser.write(comando)
        #print('Imprimiu')
        # Fechar a conexão com a impressora
        #ser.close()


        # Salvar o resultado em um arquivo TXT
        with open('resultado.txt', 'w', encoding='utf-8') as file:
            file.write(modelo_impressao)

        # Abrir o arquivo TXT automaticamente
        import os
        os.system('notepad resultado.txt')


    def lcd_display(self):
        total = 0.0  # Inicializa o total como um número decimal

# Percorre as linhas da tabela a partir da segunda linha (ignorando o cabeçalho)
        for row in range(1, self.listWidget.rowCount()):
            item = self.listWidget.item(row, 6)  # Assumindo que a coluna 4 contém os valores a serem somados
            if item is not None and item.text():
                valor = float(item.text())
                total += valor  # Adiciona o valor à soma total

        # Define o valor do QLCDNumber com o total calculado
        self.showtotal.display(total)


    def deletarLinha(self):
            # Obtém a linha selecionada atualmente
            selected_row = self.tableWidget.currentRow()

            if selected_row >= 0:
                # Obtém o ID da linha selecionada
                id_item = self.tableWidget.item(selected_row, 0)
                if id_item is not None:
                    row_id = int(id_item.text())

                    # Remove a linha do banco de dados
                    self.deletarLinhaDoBancoDeDados(row_id)

                    # Remove a linha do QTableWidget
                    self.tableWidget.removeRow(selected_row)

    def deletarLinhaDoBancoDeDados(self, row_id):
        selected_row = self.tableWidget.currentRow()

        # Verifique se uma linha está selecionada
        if selected_row >= 0:
            # Obtenha o valor da coluna "Código" (ou outra coluna que identifica exclusivamente a linha)
            codigo = self.tableWidget.item(selected_row, 0).text()

            # Conecte-se ao banco de dados e exclua a linha correspondente
            conn = sqlite3.connect('vendas.db')
            cursor = conn.cursor()
            cursor.execute('DELETE FROM Produtos WHERE Código = ?', (codigo,))
            conn.commit()
            conn.close()

            # Remova a linha da QTableWidget
            self.tableWidget.removeRow(selected_row)
        else:
            # Nenhuma linha selecionada, exiba uma mensagem ou tratamento de erro adequado
            QMessageBox.warning(self, 'Aviso', 'Selecione uma linha para excluir.')
        self.produtos_carregar()


    def add_produtos(self):
        codigo = self.codigo.text()
        produto = self.produto.text()
        valor = self.valor.text()

        # Conecte-se ao banco de dados
        conn = sqlite3.connect("vendas.db")
        cursor = conn.cursor()

        # Execute uma instrução SQL para inserir os valores na tabela "Produtos"
        cursor.execute("INSERT INTO Produtos (Código, Produto, Valor) VALUES (?, ?, ?)", (codigo, produto, valor))

        # Faça o commit das alterações e feche a conexão
        conn.commit()
        conn.close()
        
        self.codigo.clear()
        self.produto.clear()
        self.valor.clear()

        self.produtos_carregar()
        
            
if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
